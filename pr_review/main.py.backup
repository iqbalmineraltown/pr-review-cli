import asyncio
import typer
from rich.console import Console
from pathlib import Path

from .config import Config
from .bitbucket_client import BitbucketClient
from .claude_analyzer import ClaudeAnalyzer
from .priority_scorer import PriorityScorer
from .prompt_loader import PromptLoader
from .presenters.interactive_tui import launch_interactive_tui
from .presenters.report_generator import (
    generate_terminal_report,
    generate_markdown_report,
    generate_json_report
)

app = typer.Typer()
console = Console()


@app.command()
def review(
    workspace: str = typer.Argument(..., help="Bitbucket workspace"),
    repo: str = typer.Argument(None, help="Repository name (optional - if not specified, searches all repos in workspace)"),
    username: str = typer.Option(None, "--username", "-u", help="Bitbucket username (for app password authentication)"),
    prompt: str = typer.Option("default", "--prompt", "-p", help="Custom prompt to use"),
    interactive: bool = typer.Option(True, "--interactive/--no-interactive", "-i/-I"),
    export: str = typer.Option(None, "--export", "-e", help="Export format: markdown/json"),
    output: str = typer.Option("pr_report", "--output", "-o", help="Output file path"),
    max_prs: int = typer.Option(30, "--max-prs", "-m", help="Max PRs to analyze"),
):
    """
    Fetch and analyze PRs assigned to you as a reviewer from Bitbucket with AI assistance.

    If REPO is not specified, searches across ALL repositories in the workspace.
    """
    async def _review():
        # 0. Validate configuration
        try:
            config = Config()

            # Check if using OAuth or legacy token
            if config.is_using_oauth:
                # Using OAuth
                pass  # Will initialize BitbucketClient with OAuth creds
            elif config.bitbucket_token:
                # Using legacy token
                pass  # Will initialize with access token only
            else:
                console.print("\n[red]‚ùå Error:[/red] No Bitbucket credentials found.")
                console.print("\nPlease choose one of these authentication methods:\n")

                console.print("[cyan]Option 1: OAuth (Recommended)[/cyan]")
                console.print("  Run: python3 oauth_helper.py <CLIENT_ID> <CLIENT_SECRET>")
                console.print("  Then set these environment variables:")
                console.print("    export PR_REVIEWER_BITBUCKET_CLIENT_ID=\"...\"")
                console.print("    export PR_REVIEWER_BITBUCKET_CLIENT_SECRET=\"...\"")
                console.print("    export PR_REVIEWER_BITBUCKET_REFRESH_TOKEN=\"...\"")
                console.print("    export PR_REVIEWER_BITBUCKET_USERNAME=\"iqbal2512\"\n")

                console.print("[cyan]Option 2: Repository Access Token[/cyan]")
                console.print("  export PR_REVIEWER_BITBUCKET_ACCESS_TOKEN=\"your_repository_token\"")
                console.print("  export PR_REVIEWER_BITBUCKET_USERNAME=\"iqbal2512\"\n")

                raise typer.Exit(1)

        except RuntimeError as e:
            console.print(f"[red]Error: {e}[/red]")
            raise typer.Exit(1)

        # Initialize prompt loader (creates directories if needed)
        prompt_loader = PromptLoader(config.config_dir)

        # Show prompt notification
        console.print("\n[dim]üí° Custom prompts available in:[/dim]")
        console.print(f"   [dim]{prompt_loader.prompts_dir}[/dim]")
        console.print(f"   [dim]Drop .md files there to create custom analysis prompts![/dim]\n")

        # Verify requested prompt exists
        available_prompts = prompt_loader.list_prompts()
        if prompt not in available_prompts:
            console.print(f"[red]Error:[/red] Prompt '{prompt}' not found!")
            console.print(f"\n[cyan]Available prompts:[/cyan]")
            for p in available_prompts:
                console.print(f"  ‚Ä¢ {p}")
            raise typer.Exit(1)

        # Load the custom prompt
        prompt_template = prompt_loader.load_prompt(prompt)

        # 1. Initialize Bitbucket client and auto-detect current user
        with console.status("[cyan]Connecting to Bitbucket...[/cyan]"):
            async with BitbucketClient(config.bitbucket_token, config.bitbucket_base_url, bitbucket_username) as client:
                current_user = None

                # Try to get user info from /user endpoint (may fail with some API tokens)
                try:
                    current_user = await client.get_current_user()
                    console.print(f"[green]‚úì[/green] Authenticated as [bold]{current_user.display_name}[/bold] ({current_user.username})")
                    user_uuid = current_user.uuid
                    user_username = None  # Not needed since we have UUID
                except RuntimeError as e:
                    if "user_endpoint_not_accessible" in str(e):
                        # /user endpoint not accessible, use username instead
                        if bitbucket_username:
                            console.print(f"[green]‚úì[/green] Authenticated as [bold]{bitbucket_username}[/bold]")
                            user_uuid = None
                            user_username = bitbucket_username
                        else:
                            console.print("\n[red]‚ùå Error:[/red] Cannot determine your identity.")
                            console.print("Your API token doesn't have the [cyan]account:read[/cyan] scope.")
                            console.print("\nPlease provide your Bitbucket username:")
                            console.print("  1. Set environment variable:")
                            console.print("     [cyan]export PR_REVIEWER_BITBUCKET_USERNAME=your_username[/cyan]")
                            console.print("  2. Or use CLI option:")
                            console.print(f"     [cyan]--username your_username[/cyan]")
                            console.print("\nAlternatively, recreate your API token with the [cyan]account:read[/cyan] scope.\n")
                            raise typer.Exit(1)
                    elif "token_invalid_or_expired" in str(e):
                        error_msg = str(e).split(":", 1)[1] if ":" in str(e) else "Token is invalid or expired"
                        console.print("\n[red]‚ùå Authentication Error:[/red]")
                        console.print(f"[dim]{error_msg}[/dim]")
                        console.print("\nPlease check your API token:")
                        console.print("  1. Go to: https://bitbucket.org/account/settings/api-tokens/")
                        console.print("  2. Verify the token exists and is not expired")
                        console.print("  3. Ensure it has the [cyan]pullrequest:read[/cyan] scope")
                        console.print("  4. Copy the token again and update your environment:\n")
                        console.print("     [cyan]export PR_REVIEWER_BITBUCKET_ACCESS_TOKEN=your_new_token[/cyan]\n")
                        raise typer.Exit(1)
                    else:
                        raise

                # 2. Fetch PRs assigned to you as reviewer
                if repo:
                    search_scope = f"[cyan]{workspace}/{repo}[/cyan]"
                else:
                    search_scope = f"[cyan]all repositories in {workspace}[/cyan]"

                with console.status(f"[cyan]Fetching PRs assigned to you for review in {search_scope}...[/cyan]"):
                    prs, diffs = await client.fetch_prs_and_diffs(workspace, repo, user_uuid, user_username)

                if not prs:
                    console.print("[yellow]No PRs assigned to you for review. You're all caught up! üéâ[/yellow]")
                    return  # Exit gracefully without error

                repo_text = f" in {workspace}/{repo}" if repo else f" across all repositories in {workspace}"
                console.print(f"[green]‚úì[/green] Found [bold]{len(prs)}[/bold] PR(s) requiring your review{repo_text}")

                # Limit PRs if specified
                prs = prs[:max_prs]
                diffs = diffs[:max_prs]
                if len(prs) < max_prs:
                    console.print(f"[dim]Processing {len(prs)} PRs (limited from {max_prs})[/dim]")

                # 3. Analyze with Claude (parallel processing)
                with console.status("[cyan]Analyzing PRs with Claude...[/cyan]"):
                    analyzer = ClaudeAnalyzer(prompt_template=prompt_template)
                    analyses = await analyzer.analyze_prs_parallel(prs, diffs)

                # 4. Calculate priority scores
                with console.status("[cyan]Calculating priorities...[/cyan]"):
                    scorer = PriorityScorer(config.cache_dir)
                    prs_with_priority = scorer.score_prs(prs, analyses, diffs)

                # 5. Present results
                if interactive:
                    launch_interactive_tui(prs_with_priority)
                else:
                    generate_terminal_report(prs_with_priority)

                # 6. Export if requested
                if export:
                    if export == "markdown":
                        output_path = f"{output}.md"
                        generate_markdown_report(prs_with_priority, output_path)
                        console.print(f"[green]‚úì[/green] Report exported to [cyan]{output_path}[/cyan]")
                    elif export == "json":
                        output_path = f"{output}.json"
                        generate_json_report(prs_with_priority, output_path)
                        console.print(f"[green]‚úì[/green] Report exported to [cyan]{output_path}[/cyan]")
                    else:
                        console.print(f"[red]Unknown export format: {export}[/red]")

    # Run the async function
    try:
        asyncio.run(_review())
    except RuntimeError as e:
        console.print(f"\n[red]{str(e)}[/red]\n")
        raise typer.Exit(1)
    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user[/yellow]")
        raise typer.Exit(0)


@app.command()
def prompts(
    list_only: bool = typer.Option(False, "--list", "-l", help="List available prompts"),
):
    """Manage custom analysis prompts"""
    prompt_loader = PromptLoader()

    console.print(f"\n[cyan]Prompt Directory:[/cyan] {prompt_loader.prompts_dir}\n")

    available_prompts = prompt_loader.list_prompts()

    if list_only:
        console.print("[bold]Available Prompts:[/bold]\n")
        for prompt_name in available_prompts:
            metadata = prompt_loader.get_prompt_metadata(prompt_name)
            description = metadata.get("description", "No description")
            tags = metadata.get("tags", [])

            console.print(f"  ‚Ä¢ [bold]{prompt_name}[/bold]")
            if description:
                console.print(f"    {description}")
            if tags:
                console.print(f"    [dim]Tags: {', '.join(tags)}[/dim]")
            console.print()
    else:
        console.print("[bold]Available Prompts:[/bold]\n")
        for prompt_name in available_prompts:
            console.print(f"  ‚Ä¢ {prompt_name}")

        console.print("\n[bold]Usage:[/bold]")
        console.print("  pr-review review <workspace> <repo> --prompt <name>")
        console.print("\n[bold]To create a custom prompt:[/bold]")
        console.print(f"  1. Create a .md file in: {prompt_loader.prompts_dir}")
        console.print("  2. Use placeholders: {title}, {author}, {source}, {destination}, {diff}")
        console.print("  3. Response must be valid JSON format")


@app.command()
def cache_stats():
    """Show cached author statistics"""
    config = Config()
    cache_dir = config.cache_dir
    author_cache_file = cache_dir / "author_history.json"

    console.print(f"\n[cyan]Cache Directory:[/cyan] {cache_dir}\n")

    if author_cache_file.exists():
        import json
        with open(author_cache_file, 'r') as f:
            author_history = json.load(f)

        console.print(f"[bold]Author PR History:[/bold]\n")
        sorted_authors = sorted(author_history.items(), key=lambda x: x[1], reverse=True)
        for author, count in sorted_authors[:20]:
            console.print(f"  ‚Ä¢ {author}: {count} PRs")

        if len(sorted_authors) > 20:
            console.print(f"\n  [dim]... and {len(sorted_authors) - 20} more authors[/dim]")
    else:
        console.print("[yellow]No author history cached yet[/yellow]")


if __name__ == "__main__":
    app()
